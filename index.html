<!doctype html>
<html lang="en-GB">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>Band Gap Data Explorer</title>

    <!-- 3Dmol.js (CDN) -->
    <script src="https://3dmol.csb.pitt.edu/build/3Dmol-min.js"></script>

    <style>
      :root {
        --border: #e6e6e6;
        --bg: #f6f5f3;
        --panel: #ffffff;
        --text: #2b2b2b;
        --muted: #6f6f6f;
        --accent: #4156d9;
        --danger: #b00020;
        --shadow: 0 10px 24px rgba(0, 0, 0, 0.08);
      }

      body {
        margin: 0;
        font-family: "Avenir Next", "Segoe UI", Tahoma, sans-serif;
        background: var(--bg);
        color: var(--text);
      }

      .topbar {
        display: flex;
        align-items: center;
        gap: 16px;
        padding: 16px 24px 0;
      }

      .topbar h1 {
        margin: 0;
        font-size: 20px;
        font-weight: 700;
      }

      .search {
        display: flex;
        align-items: center;
        gap: 8px;
        flex-wrap: wrap;
      }

      .search input {
        width: 100%;
        min-width: 160px;
        flex: 1;
        padding: 8px 10px;
        border-radius: 10px;
        border: 1px solid var(--border);
        font-size: 14px;
        background: #fff;
      }

      .search button {
        padding: 8px 12px;
        border-radius: 10px;
        border: 1px solid var(--border);
        background: #fff;
        cursor: pointer;
        font-size: 14px;
        width: fit-content;
      }

      .search button:hover {
        background: #f2f4ff;
      }

      .search-status {
        font-size: 13px;
        color: var(--muted);
        white-space: nowrap;
      }

      .app {
        display: grid;
        grid-template-columns: 280px 1fr 360px;
        gap: 24px;
        padding: 20px 24px 28px;
        min-height: 100vh;
        box-sizing: border-box;
      }

      /* Sidebar */
      .sidebar {
        background: transparent;
        display: flex;
        flex-direction: column;
        gap: 16px;
      }

      .material-card {
        background: var(--panel);
        border-radius: 14px;
        padding: 18px;
        box-shadow: var(--shadow);
        display: grid;
        grid-template-columns: 56px 1fr;
        gap: 14px;
        align-items: center;
      }

      .material-thumb {
        width: 56px;
        height: 56px;
        border-radius: 12px;
        background: linear-gradient(135deg, #dfe8ff, #c7d6ff);
        display: grid;
        place-items: center;
        color: #3751a1;
      }

      .material-thumb img {
        width: 42px;
        height: 42px;
        object-fit: contain;
        border-radius: 8px;
        box-shadow: 0 2px 6px rgba(0, 0, 0, 0.08);
        background: #fff;
      }

      .thumb-fallback {
        font-weight: 700;
        font-size: 12px;
        color: #3751a1;
      }

      #thumb-render {
        position: absolute;
        left: -9999px;
        top: -9999px;
        width: 96px;
        height: 96px;
        overflow: hidden;
      }

      .material-title {
        margin: 0;
        font-size: 24px;
        font-weight: 700;
      }

      .formula-text sub {
        font-size: 0.65em;
        vertical-align: -0.2em;
      }

      .material-sub {
        margin: 4px 0 0;
        color: var(--muted);
      }

      .meta-card {
        background: var(--panel);
        border-radius: 14px;
        padding: 14px 16px;
        box-shadow: var(--shadow);
        display: grid;
        gap: 10px;
      }

      .meta-row {
        display: flex;
        align-items: center;
        justify-content: space-between;
        font-size: 13px;
        color: var(--muted);
      }

      .meta-row strong {
        color: var(--text);
        font-weight: 600;
      }

      .download-btn {
        display: inline-flex;
        align-items: center;
        justify-content: center;
        padding: 10px 12px;
        border-radius: 10px;
        border: 1px solid var(--border);
        background: #fff;
        color: var(--text);
        font-size: 14px;
        text-decoration: none;
        cursor: pointer;
      }

      .download-btn:hover {
        background: #f2f4ff;
      }

      .action-card {
        background: var(--panel);
        border-radius: 14px;
        box-shadow: var(--shadow);
        padding: 14px 16px;
        display: grid;
        gap: 10px;
      }

      .action-card a {
        justify-content: center;
      }


      /* Main viewer */
      .viewer-area {
        display: flex;
        flex-direction: column;
        gap: 16px;
      }

      .viewer-card {
        background: var(--panel);
        border-radius: 16px;
        box-shadow: var(--shadow);
        padding: 16px;
        position: relative;
      }

      .viewer-toolbar {
        position: absolute;
        top: 16px;
        right: 16px;
        display: flex;
        flex-direction: column;
        gap: 8px;
        z-index: 10;
      }

      .viewer-toolbar button {
        min-width: 120px;
        padding: 8px 10px;
        border-radius: 10px;
        border: 1px solid var(--border);
        background: #fff;
        cursor: pointer;
        font-size: 12px;
        text-align: center;
      }

      .viewer-toolbar button:hover {
        background: #f2f4ff;
      }

      .viewer-stage {
        position: relative;
      }

      #viewer {
        position: relative;
        width: 100%;
        height: 520px;
        border-radius: 12px;
        background: #fff;
        overflow: hidden;
        font-family: "Avenir Next", "Segoe UI", Tahoma, sans-serif;
      }

      #viewer canvas {
        font-family: "Avenir Next", "Segoe UI", Tahoma, sans-serif;
      }

      .atom-tooltip {
        position: absolute;
        left: -9999px;
        top: -9999px;
        padding: 6px 8px;
        background: #ffffff;
        border: 1px solid var(--border);
        border-radius: 8px;
        font-size: 12px;
        color: var(--text);
        box-shadow: var(--shadow);
        pointer-events: none;
        opacity: 0;
        transition: opacity 120ms ease;
        white-space: nowrap;
        z-index: 20;
        font-family: "Avenir Next", "Segoe UI", Tahoma, sans-serif;
      }

      .viewer-footer {
        display: flex;
        align-items: center;
        justify-content: space-between;
        margin-top: 8px;
        color: var(--muted);
        font-size: 13px;
      }

      .legend {
        display: flex;
        gap: 8px;
      }

      .legend span {
        display: inline-flex;
        align-items: center;
        gap: 6px;
        padding: 4px 8px;
        border-radius: 999px;
        background: #eef1ff;
        color: #2d3f8f;
        font-size: 12px;
      }

      /* Inspector column */
      .inspector {
        display: flex;
        flex-direction: column;
        gap: 16px;
      }

      .panel-title {
        margin: 0;
        font-size: 16px;
        font-weight: 700;
        color: var(--text);
      }

      .info-card {
        background: var(--panel);
        border-radius: 14px;
        box-shadow: var(--shadow);
        padding: 16px;
      }

      .card-title {
        margin: 0 0 10px;
        font-size: 13px;
        font-weight: 700;
        text-transform: uppercase;
        letter-spacing: 0.12em;
        color: var(--muted);
      }

      .info-row {
        display: flex;
        align-items: center;
        justify-content: space-between;
        padding: 8px 0;
        border-bottom: 1px solid var(--border);
        font-size: 14px;
      }
      .info-row:last-child {
        border-bottom: none;
      }
      .info-row strong {
        font-weight: 600;
      }
      .info-row span {
        color: var(--accent);
      }

      .prop-table {
        width: 100%;
        border-collapse: collapse;
        font-size: 13px;
      }

      .prop-table th,
      .prop-table td {
        text-align: left;
        padding: 6px 0;
        border-bottom: 1px solid var(--border);
      }

      .prop-table th {
        font-weight: 600;
        color: var(--text);
        width: 40%;
      }

      .prop-table td {
        color: var(--accent);
      }

      .prop-table tr:last-child th,
      .prop-table tr:last-child td {
        border-bottom: none;
      }

      .atom-table th,
      .atom-table td {
        width: auto;
        padding-right: 8px;
      }

      .atom-table td {
        color: var(--text);
      }

      .table-note {
        margin-top: 8px;
        font-size: 12px;
        color: var(--muted);
      }

      .desc {
        font-size: 14px;
        color: var(--text);
        line-height: 1.45;
        max-height: 180px;
        overflow: auto;
      }

      .status {
        font-size: 13px;
        color: var(--muted);
      }
      .status.err {
        color: var(--danger);
      }


      code {
        background: #f2f2f2;
        padding: 2px 6px;
        border-radius: 6px;
      }

      @media (max-width: 1100px) {
        .app {
          grid-template-columns: 1fr;
        }
        .viewer-toolbar {
          flex-direction: row;
        }
        .inspector {
          order: 3;
        }
      }
    </style>
  </head>

  <body>
    <header class="topbar">
      <h1>CIF Viewer</h1>
    </header>
    <div class="app">
      <aside class="sidebar">
        <section class="material-card" aria-label="Material summary">
          <div class="material-thumb" aria-hidden="true">
            <img id="thumb-img" alt="Structure thumbnail" />
            <span class="thumb-fallback">CIF</span>
          </div>
          <div>
            <h1 class="material-title formula-text" id="comp">—</h1>
            <p class="material-sub">mp-id: <span id="mpid">—</span></p>
          </div>
        </section>

        <section class="meta-card" aria-label="Material metadata">
          <div class="meta-row"><span>Last Loaded</span><strong id="meta-loaded">—</strong></div>
          <div class="search" role="search">
            <input id="search-input" type="search" placeholder="Search mp-id (e.g., mp-7)" />
            <button id="search-btn" type="button">Search</button>
            <span class="search-status" id="search-status">Ready</span>
          </div>
        </section>

        <section class="info-card" aria-label="Key properties">
          <h3 class="card-title">Key Properties</h3>
          <div class="info-row"><strong>Band Gap (Exp.)</strong><span id="prop-bg-exp">—</span></div>
          <div class="info-row"><strong>Band Gap (PBE)</strong><span id="prop-bg-pbe">—</span></div>
          <div class="info-row"><strong>Space Group</strong><span id="prop-sg">—</span></div>
          <div class="info-row">
            <strong>Formula (sum)</strong><span class="formula-text" id="prop-formula">—</span>
          </div>
          <div class="info-row"><strong>Number of Atoms</strong><span id="prop-natoms">—</span></div>
        </section>
        <section class="action-card" aria-label="Material actions">
          <a class="download-btn" id="download-cif" href="#" download>Download CIF</a>
          <a class="download-btn" id="mp-link" href="#" target="_blank" rel="noopener">View on Materials Project</a>
        </section>
      </aside>

      <main class="viewer-area">
        <section class="viewer-card" aria-label="Structure plot">
          <div class="viewer-toolbar" aria-label="Viewer controls">
            <button id="btn-stick" type="button">Stick + sphere</button>
            <button id="btn-sphere" type="button">Sphere</button>
            <button id="btn-line" type="button">Line</button>
            <button id="btn-reset" type="button">Reset view</button>
            <button id="btn-download-json" type="button">Download JSON</button>
          </div>
          <div class="viewer-stage">
            <div id="viewer" aria-label="3D crystal structure viewer"></div>
            <div class="atom-tooltip" id="atom-tooltip" role="status" aria-live="polite"></div>
          </div>
          <div class="viewer-footer">
            <span class="status" id="status">Initialising…</span>
          </div>
        </section>
      </main>

      <aside class="inspector">
        <h2 class="panel-title">Crystal Structure</h2>
        <section class="info-card" aria-label="Lattice conventional">
          <h3 class="card-title">Lattice (Conventional)</h3>
          <table class="prop-table">
            <tbody>
              <tr><th>a</th><td id="lat-a">—</td></tr>
              <tr><th>b</th><td id="lat-b">—</td></tr>
              <tr><th>c</th><td id="lat-c">—</td></tr>
              <tr><th>α</th><td id="lat-alpha">—</td></tr>
              <tr><th>β</th><td id="lat-beta">—</td></tr>
              <tr><th>γ</th><td id="lat-gamma">—</td></tr>
              <tr><th>Volume</th><td id="lat-vol">—</td></tr>
              <tr><th>Z</th><td id="lat-z">—</td></tr>
            </tbody>
          </table>
        </section>

        <section class="info-card" aria-label="Atomic positions">
          <h3 class="card-title">Atomic Positions</h3>
          <table class="prop-table atom-table">
            <thead>
              <tr>
                <th>Element</th>
                <th>x</th>
                <th>y</th>
                <th>z</th>
              </tr>
            </thead>
            <tbody id="atom-table-body">
              <tr><td colspan="4">—</td></tr>
            </tbody>
          </table>
          <div class="table-note" id="atom-table-note"></div>
        </section>
      </aside>
    </div>
    <div id="thumb-render" aria-hidden="true"></div>

    <script>
      const DEFAULT_MPID = "mp-7";
      const CIF_BASE = "data/cif-files";
      const DATA_INDEX = "data/data.json";

      const mpidEl = document.getElementById("mpid");
      const compEl = document.getElementById("comp");
      const statusEl = document.getElementById("status");
      const viewerEl = document.getElementById("viewer");
      const tooltipEl = document.getElementById("atom-tooltip");
      const searchInput = document.getElementById("search-input");
      const searchBtn = document.getElementById("search-btn");
      const searchStatus = document.getElementById("search-status");
      const metaLoadedEl = document.getElementById("meta-loaded");
      const thumbImgEl = document.getElementById("thumb-img");
      const thumbFallbackEl = document.querySelector(".thumb-fallback");
      const thumbRenderEl = document.getElementById("thumb-render");
      const propBgExpEl = document.getElementById("prop-bg-exp");
      const propBgPbeEl = document.getElementById("prop-bg-pbe");
      const propSgEl = document.getElementById("prop-sg");
      const propFormulaEl = document.getElementById("prop-formula");
      const propNatomsEl = document.getElementById("prop-natoms");
      const downloadCifEl = document.getElementById("download-cif");
      const mpLinkEl = document.getElementById("mp-link");
      const downloadJsonBtn = document.getElementById("btn-download-json");
      const latAEl = document.getElementById("lat-a");
      const latBEl = document.getElementById("lat-b");
      const latCEl = document.getElementById("lat-c");
      const latAlphaEl = document.getElementById("lat-alpha");
      const latBetaEl = document.getElementById("lat-beta");
      const latGammaEl = document.getElementById("lat-gamma");
      const latVolEl = document.getElementById("lat-vol");
      const latZEl = document.getElementById("lat-z");
      const atomTableBody = document.getElementById("atom-table-body");
      const atomTableNote = document.getElementById("atom-table-note");

      let viewer = null;
      let currentStyle = "stick";
      let availableIds = null;
      let dataIndex = null;
      let formulaCache = {};
      let initialView = null;
      let currentMpid = DEFAULT_MPID;
      let hoverBound = false;
      let hoverRaf = null;

      function setStatus(msg, isError = false) {
        statusEl.textContent = msg;
        statusEl.classList.toggle("err", isError);
      }

      function setSearchStatus(msg, isError = false) {
        searchStatus.textContent = msg;
        searchStatus.style.color = isError ? "var(--danger)" : "var(--muted)";
      }

      function inferMpidFromPath(path) {
        // Example: data/cif-files/mp-7.cif -> mp-7
        const base = path.split("/").pop() || "";
        return base.replace(/\.cif$/i, "") || "—";
      }

      function normaliseMpid(raw) {
        const cleaned = (raw || "").trim().toLowerCase().replace(/\.cif$/i, "");
        if (!cleaned) return "";
        if (cleaned.startsWith("mp-")) return cleaned;
        if (/^\d+$/.test(cleaned)) return `mp-${cleaned}`;
        return cleaned;
      }

      function parseTagValue(cifText, tag) {
        // Matches lines like:
        // _chemical_formula_sum   S6
        // _chemical_formula_sum   'S6'
        const escaped = tag.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
        const re = new RegExp("^\\s*" + escaped + "\\s+(.+?)\\s*$", "mi");
        const m = cifText.match(re);
        if (!m) return null;
        return m[1].trim().replace(/^['"]|['"]$/g, "");
      }

      function parseFormulaElements(formula) {
        if (!formula) return [];
        const cleaned = String(formula).replace(/\s+/g, "");
        const elems = new Set();
        const re = /([A-Z][a-z]?)/g;
        let match;
        while ((match = re.exec(cleaned)) !== null) {
          elems.add(match[1]);
        }
        return Array.from(elems);
      }

      function normaliseElementSymbol(raw) {
        const trimmed = (raw || "").trim();
        if (!trimmed) return "";
        const lower = trimmed.toLowerCase();
        return lower.charAt(0).toUpperCase() + lower.slice(1);
      }

      function extractComposition(cifText) {
        // Prefer _chemical_formula_sum for display.
        const sum = parseTagValue(cifText, "_chemical_formula_sum");
        if (sum) return sum;

        // Fallback to _chemical_formula_structural (may be less informative).
        const structural = parseTagValue(cifText, "_chemical_formula_structural");
        if (structural) return structural;

        return "N/A";
      }

      function escapeHtml(raw) {
        return String(raw)
          .replace(/&/g, "&amp;")
          .replace(/</g, "&lt;")
          .replace(/>/g, "&gt;");
      }

      function formatFormulaHtml(formula) {
        if (!formula || formula === "N/A") return formula || "—";
        const compact = String(formula).replace(/\s+/g, "");
        const safe = escapeHtml(compact);
        return safe
          .replace(/([A-Za-z\)])1(?!\d)/g, "$1")
          .replace(/(\d+)/g, "<sub>$1</sub>");
      }

      function formatNum(val, digits = 3) {
        if (val === null || val === undefined || val === "") return "—";
        const num = Number(val);
        if (Number.isNaN(num)) return String(val);
        return num.toFixed(digits);
      }

      const ELEMENT_COLORS = {
        H: "#5496CE",
        C: "#5EB342",
        N: "#E9C54E",
        O: "#F29742",
        F: "#B778B3",
        P: "#96A0B3",
        S: "#DC6464",
        Cl: "#C5C500",
        Br: "#E0DCCA",
        I: "#96CED3",
      };
      const FALLBACK_PALETTE = ["#5E81AC", "#88C0D0", "#A3BE8C", "#EBCB8B", "#D08770", "#BF616A", "#B48EAD", "#8FBCBB"];

      function getElementColor(elem) {
        if (!elem) return FALLBACK_PALETTE[0];
        if (ELEMENT_COLORS[elem]) return ELEMENT_COLORS[elem];
        let hash = 0;
        for (let i = 0; i < elem.length; i += 1) {
          hash = (hash * 31 + elem.charCodeAt(i)) | 0;
        }
        return FALLBACK_PALETTE[Math.abs(hash) % FALLBACK_PALETTE.length];
      }

      function setThumbnail(src) {
        if (!thumbImgEl) return;
        if (src) {
          thumbImgEl.src = src;
          if (thumbFallbackEl) thumbFallbackEl.style.display = "none";
        } else {
          thumbImgEl.removeAttribute("src");
          if (thumbFallbackEl) thumbFallbackEl.style.display = "block";
        }
      }

      function updateThumbnail(cifText, mpid) {
        if (!thumbImgEl || !thumbRenderEl) return;
        const key = `cif-thumb:${mpid}`;
        try {
          const cached = localStorage.getItem(key);
          if (cached) {
            setThumbnail(cached);
            return;
          }
        } catch (e) {
          // ignore storage errors
        }

        if (typeof $3Dmol === "undefined") return;

        const thumbViewer = $3Dmol.createViewer(thumbRenderEl, { backgroundColor: "white" });
        thumbViewer.addModel(cifText, "cif");
        thumbViewer.setStyle(
          {},
          {
            stick: { radius: 0.18, colorscheme: "Jmol" },
            sphere: { scale: 0.36, colorscheme: "Jmol" },
          }
        );
        thumbViewer.zoomTo();
        thumbViewer.render();

        let uri = "";
        if (thumbViewer.pngURI) {
          uri = thumbViewer.pngURI();
        } else if (thumbViewer.getCanvas) {
          const canvas = thumbViewer.getCanvas();
          if (canvas && canvas.toDataURL) uri = canvas.toDataURL("image/png");
        }

        if (uri) {
          setThumbnail(uri);
          try {
            localStorage.setItem(key, uri);
          } catch (e) {
            // ignore storage quota errors
          }
        }
        thumbViewer.removeAllModels();
      }

      function parseAtomSites(cifText) {
        const lines = cifText.split(/\r?\n/);
        let inLoop = false;
        let tags = [];
        let data = [];
        let isAtomLoop = false;
        const atoms = [];
        const needed = ["_atom_site_fract_x", "_atom_site_fract_y", "_atom_site_fract_z"];

        const flushRow = (row) => {
          const get = (name) => {
            const idx = tags.indexOf(name);
            return idx >= 0 ? row[idx] : null;
          };
          const elem = get("_atom_site_type_symbol") || get("_atom_site_label") || "—";
          const x = get("_atom_site_fract_x");
          const y = get("_atom_site_fract_y");
          const z = get("_atom_site_fract_z");
          atoms.push({ elem, x, y, z });
        };

        for (const raw of lines) {
          const line = raw.trim();
          if (!line || line.startsWith("#")) {
            if (inLoop && !line && isAtomLoop) break;
            if (!line) {
              inLoop = false;
              tags = [];
              data = [];
              isAtomLoop = false;
            }
            continue;
          }

          if (line.startsWith("loop_")) {
            if (isAtomLoop) break;
            inLoop = true;
            tags = [];
            data = [];
            isAtomLoop = false;
            continue;
          }

          if (inLoop && line.startsWith("_")) {
            const tag = line.split(/\s+/)[0];
            tags.push(tag);
            continue;
          }

          if (inLoop && tags.length) {
            if (line.startsWith("data_")) {
              if (isAtomLoop) break;
              inLoop = false;
              tags = [];
              data = [];
              isAtomLoop = false;
              continue;
            }

            if (!isAtomLoop) {
              const hasNeeded = needed.every((t) => tags.includes(t));
              if (!hasNeeded) {
                continue;
              }
              isAtomLoop = true;
            }

            const tokens = line.match(/'[^']*'|\"[^\"]*\"|\S+/g) || [];
            data.push(...tokens.map((tok) => tok.replace(/^['"]|['"]$/g, "")));
            const n = tags.length;
            while (data.length >= n) {
              const row = data.slice(0, n);
              data = data.slice(n);
              flushRow(row);
            }
          }
        }

        return atoms;
      }

      function updatePropertyPanel(cifText, mpid) {
        const bgExp = dataIndex?.[mpid]?.bg_exp;
        const bgPbe = dataIndex?.[mpid]?.bg_comp;
        propBgExpEl.textContent = bgExp === undefined || bgExp === null ? "—" : `${formatNum(bgExp, 2)} eV`;
        propBgPbeEl.textContent = bgPbe === undefined || bgPbe === null ? "—" : `${formatNum(bgPbe, 2)} eV`;

        const sg = parseTagValue(cifText, "_symmetry_space_group_name_H-M");
        const formula = parseTagValue(cifText, "_chemical_formula_sum");
        const atoms = parseAtomSites(cifText);

        const a = parseTagValue(cifText, "_cell_length_a");
        const b = parseTagValue(cifText, "_cell_length_b");
        const c = parseTagValue(cifText, "_cell_length_c");
        const alpha = parseTagValue(cifText, "_cell_angle_alpha");
        const beta = parseTagValue(cifText, "_cell_angle_beta");
        const gamma = parseTagValue(cifText, "_cell_angle_gamma");
        const vol = parseTagValue(cifText, "_cell_volume");
        const z = parseTagValue(cifText, "_cell_formula_units_Z");

        propSgEl.textContent = sg ? sg.replace(/^['"]|['"]$/g, "") : "—";
        propFormulaEl.innerHTML = formatFormulaHtml(formula ?? "—");
        propNatomsEl.textContent = atoms.length ? String(atoms.length) : "—";

        latAEl.textContent = `${formatNum(a)} Å`;
        latBEl.textContent = `${formatNum(b)} Å`;
        latCEl.textContent = `${formatNum(c)} Å`;
        latAlphaEl.textContent = `${formatNum(alpha)} °`;
        latBetaEl.textContent = `${formatNum(beta)} °`;
        latGammaEl.textContent = `${formatNum(gamma)} °`;
        latVolEl.textContent = `${formatNum(vol)} Å³`;
        latZEl.textContent = z ?? "—";

        const maxRows = 20;
        if (!atoms.length) {
          atomTableBody.innerHTML = '<tr><td colspan="4">—</td></tr>';
          atomTableNote.textContent = "";
        } else {
          const rows = atoms.slice(0, maxRows);
          atomTableBody.innerHTML = rows
            .map(
              (atom) =>
                `<tr><td>${atom.elem}</td><td>${formatNum(atom.x)}</td><td>${formatNum(
                  atom.y
                )}</td><td>${formatNum(atom.z)}</td></tr>`
            )
            .join("");
          atomTableNote.textContent =
            atoms.length > maxRows
              ? `Showing first ${maxRows} of ${atoms.length} atoms`
              : `Showing ${atoms.length} atoms`;
        }
      }

      function formatAtom(atom) {
        const x = Number(atom.x).toFixed(3);
        const y = Number(atom.y).toFixed(3);
        const z = Number(atom.z).toFixed(3);
        return `${atom.elem} (${x}, ${y}, ${z})`;
      }

      function hideTooltip() {
        tooltipEl.style.opacity = "0";
        tooltipEl.style.left = "-9999px";
        tooltipEl.style.top = "-9999px";
      }

      function showTooltip(atom, event) {
        if (!atom || !tooltipEl) return;
        tooltipEl.textContent = formatAtom(atom);
        tooltipEl.style.opacity = "1";

        const rect = viewerEl.getBoundingClientRect();
        const x = (event?.clientX ?? rect.left + rect.width / 2) - rect.left;
        const y = (event?.clientY ?? rect.top + rect.height / 2) - rect.top;

        requestAnimationFrame(() => {
          const pad = 10;
          const w = tooltipEl.offsetWidth;
          const h = tooltipEl.offsetHeight;
          let left = x + 12;
          let top = y + 12;

          if (left + w + pad > rect.width) {
            left = x - w - 12;
          }
          if (top + h + pad > rect.height) {
            top = y - h - 12;
          }
          tooltipEl.style.left = `${Math.max(pad, left)}px`;
          tooltipEl.style.top = `${Math.max(pad, top)}px`;
        });
      }

      function pickAtomFromEvent(event) {
        if (!viewer || !viewerEl) return null;
        const tryPick = (x, y, height) => {
          if (!viewer.pick) return null;
          let picked = null;
          try {
            picked = viewer.pick(x, y);
          } catch (e) {
            try {
              picked = viewer.pick({ x, y });
            } catch (err) {
              picked = null;
            }
          }
          if (!picked && typeof height === "number") {
            const yFlip = height - y;
            try {
              picked = viewer.pick(x, yFlip);
            } catch (e) {
              try {
                picked = viewer.pick({ x, y: yFlip });
              } catch (err) {
                picked = null;
              }
            }
          }
          if (picked && picked.atom) return picked.atom;
          return picked || null;
        };

        const rect = viewerEl.getBoundingClientRect();
        const x = event.clientX - rect.left;
        const y = event.clientY - rect.top;
        let picked = tryPick(x, y, rect.height);
        if (picked) return picked;

        const canvas = viewerEl.querySelector("canvas");
        if (canvas) {
          const cRect = canvas.getBoundingClientRect();
          const cx = event.clientX - cRect.left;
          const cy = event.clientY - cRect.top;
          picked = tryPick(cx, cy, cRect.height);
          if (picked) return picked;
        }

        return null;
      }

      function bindAtomHover() {
        if (hoverBound) return;
        hoverBound = true;

        const onMove = (event) => {
          if (hoverRaf) return;
          hoverRaf = requestAnimationFrame(() => {
            hoverRaf = null;
            const atom = pickAtomFromEvent(event);
            if (atom) {
              viewerEl.style.cursor = "pointer";
              showTooltip(atom, event);
            } else {
              viewerEl.style.cursor = "grab";
              hideTooltip();
            }
          });
        };

        const onClick = (event) => {
          const atom = pickAtomFromEvent(event);
          if (atom) {
            viewerEl.style.cursor = "pointer";
            showTooltip(atom, event);
          } else {
            viewerEl.style.cursor = "grab";
            hideTooltip();
          }
        };

        viewerEl.style.cursor = "grab";
        viewerEl.addEventListener("mousemove", onMove);
        viewerEl.addEventListener("click", onClick);
        viewerEl.addEventListener("mouseleave", () => {
          viewerEl.style.cursor = "grab";
          hideTooltip();
        });
      }

      function enableAtomInteractivity() {
        if (!viewer) return;
        const hasClickable = typeof viewer.setClickable === "function";
        const hasHoverable = typeof viewer.setHoverable === "function";

        if (hasClickable) {
          viewer.setClickable({}, true, (atom, v, event) => {
            showTooltip(atom, event);
          });
        }
        if (hasHoverable) {
          viewer.setHoverable(
            {},
            true,
            (atom, v, event) => {
              showTooltip(atom, event);
            },
            () => {
              hideTooltip();
            }
          );
        }

        bindAtomHover();
      }

      function applyStyle(styleName) {
        if (!viewer) return;
        currentStyle = styleName;
        const colorfunc = (atom) => getElementColor(atom.elem);

        viewer.setStyle({}, {}); // clear existing style
        if (viewer.removeAllShapes) {
          viewer.removeAllShapes();
        }

        if (styleName === "stick") {
          viewer.setStyle(
            {},
            {
              stick: { radius: 0.16, colorfunc },
              sphere: { scale: 0.34, colorfunc },
            }
          );

        } else if (styleName === "sphere") {
          viewer.setStyle({}, { sphere: { scale: 0.35, colorfunc } });
        } else if (styleName === "line") {
          viewer.setStyle({}, { line: { colorfunc } });
        }

        viewer.resize();
        viewer.zoomTo();
        viewer.render();
      }

      document.getElementById("btn-stick").addEventListener("click", () => applyStyle("stick"));
      document.getElementById("btn-sphere").addEventListener("click", () => applyStyle("sphere"));
      document.getElementById("btn-line").addEventListener("click", () => applyStyle("line"));
      document.getElementById("btn-reset").addEventListener("click", () => {
        if (!viewer) return;
        if (initialView && viewer.setView) {
          viewer.setView(initialView);
        } else {
          viewer.zoomTo();
        }
        viewer.render();
      });

      if (downloadJsonBtn) {
        downloadJsonBtn.addEventListener("click", () => {
          if (!viewer) return;
          const data = {
            mpid: currentMpid || "",
            style: currentStyle,
            view: initialView || null,
          };
          const blob = new Blob([JSON.stringify(data, null, 2)], { type: "application/json" });
          const url = URL.createObjectURL(blob);
          const link = document.createElement("a");
          link.href = url;
          link.download = `${currentMpid || "structure"}.json`;
          document.body.appendChild(link);
          link.click();
          link.remove();
          URL.revokeObjectURL(url);
        });
      }

      async function loadAvailableIds() {
        if (availableIds) return availableIds;
        try {
          const resp = await fetch(DATA_INDEX, { cache: "no-store" });
          if (!resp.ok) throw new Error(`HTTP ${resp.status}`);
          dataIndex = await resp.json();
          availableIds = new Set(Object.keys(dataIndex || {}));
          setSearchStatus("Ready");
        } catch (e) {
          dataIndex = {};
          availableIds = new Set();
          setSearchStatus("Failed to load data.json", true);
        }
        return availableIds;
      }

      async function getFormulaForId(mpid) {
        if (formulaCache[mpid]) return formulaCache[mpid];
        const cifPath = `${CIF_BASE}/${mpid}.cif`;
        try {
          const resp = await fetch(cifPath, { cache: "no-store" });
          if (!resp.ok) throw new Error(`HTTP ${resp.status}`);
          const text = await resp.text();
          const formula = parseTagValue(text, "_chemical_formula_sum") || "";
          formulaCache[mpid] = formula;
          return formula;
        } catch (e) {
          return "";
        }
      }

      async function findIdsByElement(elementSymbol) {
        await loadAvailableIds();
        const ids = Array.from(availableIds || []);
        const matches = [];
        for (const id of ids) {
          const formula = await getFormulaForId(id);
          const elements = parseFormulaElements(formula);
          if (elements.includes(elementSymbol)) {
            matches.push(id);
          }
        }
        return matches;
      }

      async function loadCifById(mpid) {
        if (!mpid || !viewer) return false;
        const cifPath = `${CIF_BASE}/${mpid}.cif`;
        const mpUrl = `https://next-gen.materialsproject.org/materials/${mpid}`;
        currentMpid = mpid;

        setStatus(`Loading ${cifPath} …`);
        let cifText = "";
        try {
          const resp = await fetch(cifPath, { cache: "no-store" });
          if (!resp.ok) throw new Error(`HTTP ${resp.status}`);
          cifText = await resp.text();
        } catch (e) {
          setStatus(`Could not fetch ${cifPath}. (${e})`, true);
          return false;
        }

        compEl.innerHTML = formatFormulaHtml(extractComposition(cifText));
        mpidEl.textContent = mpid;
        const formulaSum = parseTagValue(cifText, "_chemical_formula_sum");
        if (formulaSum) formulaCache[mpid] = formulaSum;
        updatePropertyPanel(cifText, mpid);
        updateThumbnail(cifText, mpid);

        viewer.removeAllModels();
        viewer.addModel(cifText, "cif");
        applyStyle(currentStyle);
        enableAtomInteractivity();
        viewer.render();
        if (viewer.getView) {
          initialView = viewer.getView();
        }

        setStatus(`Loaded ${cifPath}.`);
        if (downloadCifEl) {
          downloadCifEl.href = cifPath;
          downloadCifEl.setAttribute("download", `${mpid}.cif`);
        }
        if (mpLinkEl) {
          mpLinkEl.href = mpUrl;
        }
        if (metaLoadedEl) metaLoadedEl.textContent = new Date().toLocaleString();
        return true;
      }

      async function main() {
        mpidEl.textContent = DEFAULT_MPID;

        if (typeof $3Dmol === "undefined") {
          setStatus("3Dmol.js failed to load (the CDN may be blocked). Please check your network.", true);
          return;
        }

        try {
          viewer = $3Dmol.createViewer("viewer", { backgroundColor: "white" });
          applyStyle("stick");

          enableAtomInteractivity();
        } catch (e) {
          setStatus(`Rendering error: ${e}`, true);
          return;
        }

        await loadAvailableIds();
        await loadCifById(DEFAULT_MPID);

        const onSearch = async () => {
          const query = normaliseMpid(searchInput.value);
          if (!query) return;
          await loadAvailableIds();
          if (!availableIds.has(query)) {
            const elemQuery = normaliseElementSymbol(searchInput.value);
            if (/^[A-Z][a-z]?$/.test(elemQuery)) {
              setSearchStatus(`Searching for ${elemQuery}…`);
              const matches = await findIdsByElement(elemQuery);
              if (!matches.length) {
                setSearchStatus(`No materials with ${elemQuery}`, true);
                return;
              }
              const chosen = matches[0];
              const ok = await loadCifById(chosen);
              const more = matches.length > 1 ? ` (also: ${matches.slice(1, 4).join(", ")}${
                matches.length > 4 ? "…" : ""
              })` : "";
              setSearchStatus(ok ? `Loaded ${chosen}${more}` : `Not available: ${chosen}`, !ok);
              return;
            }
            setSearchStatus(`Not available: ${query}`, true);
            return;
          }
          setSearchStatus(`Loading ${query}…`);
          const ok = await loadCifById(query);
          setSearchStatus(ok ? `Loaded ${query}` : `Not available: ${query}`, !ok);
        };

        searchBtn.addEventListener("click", onSearch);
        searchInput.addEventListener("keydown", (e) => {
          if (e.key === "Enter") onSearch();
        });
      }

      main();
    </script>
  </body>
</html>
